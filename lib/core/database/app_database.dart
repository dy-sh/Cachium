import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';

import 'daos/account_dao.dart';
import 'daos/category_dao.dart';
import 'daos/settings_dao.dart';
import 'daos/transaction_dao.dart';

part 'app_database.g.dart';

/// Table for storing encrypted transactions.
///
/// Only `id`, `date`, `lastUpdatedAt`, and `isDeleted` are stored in plaintext
/// for querying and sorting. All other transaction data is encrypted in `encryptedBlob`.
class Transactions extends Table {
  /// UUID primary key (plaintext for lookups)
  TextColumn get id => text()();

  /// Transaction date in Unix milliseconds (plaintext for sorting/filtering by date range)
  IntColumn get date => integer()();

  /// Last updated timestamp for LWW (Last-Write-Wins) sync resolution
  IntColumn get lastUpdatedAt => integer()();

  /// Soft delete flag - allows sync to propagate deletions
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();

  /// AES-GCM encrypted JSON blob containing all transaction data
  BlobColumn get encryptedBlob => blob()();

  @override
  Set<Column> get primaryKey => {id};
}

/// Table for storing encrypted accounts.
///
/// Only `id`, `createdAt`, `lastUpdatedAt`, and `isDeleted` are stored in plaintext
/// for querying and sorting. All other account data is encrypted in `encryptedBlob`.
class Accounts extends Table {
  /// UUID primary key (plaintext for lookups)
  TextColumn get id => text()();

  /// Account creation date in Unix milliseconds (plaintext for sorting)
  IntColumn get createdAt => integer()();

  /// Last updated timestamp for LWW (Last-Write-Wins) sync resolution
  IntColumn get lastUpdatedAt => integer()();

  /// Soft delete flag - allows sync to propagate deletions
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();

  /// AES-GCM encrypted JSON blob containing all account data
  BlobColumn get encryptedBlob => blob()();

  @override
  Set<Column> get primaryKey => {id};
}

/// Table for storing encrypted categories.
///
/// Only `id`, `sortOrder`, `lastUpdatedAt`, and `isDeleted` are stored in plaintext
/// for querying and sorting. All other category data is encrypted in `encryptedBlob`.
@DataClassName('CategoryRow')
class Categories extends Table {
  /// UUID primary key (plaintext for lookups)
  TextColumn get id => text()();

  /// Sort order for display ordering (plaintext for sorting)
  IntColumn get sortOrder => integer()();

  /// Last updated timestamp for LWW (Last-Write-Wins) sync resolution
  IntColumn get lastUpdatedAt => integer()();

  /// Soft delete flag - allows sync to propagate deletions
  BoolColumn get isDeleted => boolean().withDefault(const Constant(false))();

  /// AES-GCM encrypted JSON blob containing all category data
  BlobColumn get encryptedBlob => blob()();

  @override
  Set<Column> get primaryKey => {id};
}

/// Table for storing app settings.
///
/// Settings are stored as unencrypted JSON since they don't contain sensitive data.
/// Uses a single-row pattern with a fixed ID ('app_settings').
class AppSettings extends Table {
  /// Fixed ID - always 'app_settings' (single-row pattern)
  TextColumn get id => text()();

  /// Last updated timestamp for sync resolution
  IntColumn get lastUpdatedAt => integer()();

  /// JSON-encoded settings data
  TextColumn get jsonData => text()();

  @override
  Set<Column> get primaryKey => {id};
}

/// The main application database.
///
/// Uses Drift with SQLite for local persistence. In Stage 1, the database
/// is stored unencrypted on disk, but all sensitive transaction data is
/// encrypted at the application layer before being stored.
@DriftDatabase(
  tables: [Transactions, Accounts, Categories, AppSettings],
  daos: [TransactionDao, AccountDao, CategoryDao, SettingsDao],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());

  // DAO accessors (generated by Drift, declared here for clarity)
  @override
  late final transactionDao = TransactionDao(this);
  @override
  late final accountDao = AccountDao(this);
  @override
  late final categoryDao = CategoryDao(this);
  @override
  late final settingsDao = SettingsDao(this);

  @override
  int get schemaVersion => 4;

  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) async {
          await m.createAll();
        },
        onUpgrade: (Migrator m, int from, int to) async {
          // Recreate database on upgrade - no migration needed
          // Delete and recreate all tables
          await m.deleteTable('transactions');
          await m.deleteTable('accounts');
          await m.createAll();
        },
      );

  static QueryExecutor _openConnection() {
    return driftDatabase(
      name: 'cachium_db',
      native: DriftNativeOptions(
        setup: (database) {
          // Enable WAL mode for concurrent reads/writes
          database.execute('PRAGMA journal_mode=WAL');
          // Set busy timeout to 5 seconds to wait for locks instead of failing immediately
          database.execute('PRAGMA busy_timeout=5000');
        },
      ),
    );
  }

  // CRUD operations for transactions (delegates to TransactionDao)

  Future<void> insertTransaction({
    required String id,
    required int date,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      transactionDao.insert(
        id: id,
        date: date,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> upsertTransaction({
    required String id,
    required int date,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
    bool isDeleted = false,
  }) =>
      transactionDao.upsert(
        id: id,
        date: date,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
        isDeleted: isDeleted,
      );

  Future<void> updateTransaction({
    required String id,
    required int date,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      transactionDao.updateRow(
        id: id,
        date: date,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> softDeleteTransaction(String id, int lastUpdatedAt) =>
      transactionDao.softDelete(id, lastUpdatedAt);

  Future<Transaction?> getTransaction(String id) => transactionDao.getById(id);

  Future<List<Transaction>> getAllTransactions() => transactionDao.getAll();

  Stream<List<Transaction>> watchAllTransactions() => transactionDao.watchAll();

  Future<bool> hasTransactions() => transactionDao.hasAny();

  // CRUD operations for accounts (delegates to AccountDao)

  Future<void> insertAccount({
    required String id,
    required int createdAt,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      accountDao.insert(
        id: id,
        createdAt: createdAt,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> upsertAccount({
    required String id,
    required int createdAt,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
    bool isDeleted = false,
  }) =>
      accountDao.upsert(
        id: id,
        createdAt: createdAt,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
        isDeleted: isDeleted,
      );

  Future<void> updateAccount({
    required String id,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      accountDao.updateRow(
        id: id,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> softDeleteAccount(String id, int lastUpdatedAt) =>
      accountDao.softDelete(id, lastUpdatedAt);

  Future<Account?> getAccount(String id) => accountDao.getById(id);

  Future<List<Account>> getAllAccounts() => accountDao.getAll();

  Stream<List<Account>> watchAllAccounts() => accountDao.watchAll();

  Future<bool> hasAccounts() => accountDao.hasAny();

  // CRUD operations for categories (delegates to CategoryDao)

  Future<void> insertCategory({
    required String id,
    required int sortOrder,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      categoryDao.insert(
        id: id,
        sortOrder: sortOrder,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> upsertCategory({
    required String id,
    required int sortOrder,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
    bool isDeleted = false,
  }) =>
      categoryDao.upsert(
        id: id,
        sortOrder: sortOrder,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
        isDeleted: isDeleted,
      );

  Future<void> updateCategory({
    required String id,
    required int sortOrder,
    required int lastUpdatedAt,
    required Uint8List encryptedBlob,
  }) =>
      categoryDao.updateRow(
        id: id,
        sortOrder: sortOrder,
        lastUpdatedAt: lastUpdatedAt,
        encryptedBlob: encryptedBlob,
      );

  Future<void> softDeleteCategory(String id, int lastUpdatedAt) =>
      categoryDao.softDelete(id, lastUpdatedAt);

  Future<CategoryRow?> getCategory(String id) => categoryDao.getById(id);

  Future<List<CategoryRow>> getAllCategories() => categoryDao.getAll();

  Stream<List<CategoryRow>> watchAllCategories() => categoryDao.watchAll();

  Future<bool> hasCategories() => categoryDao.hasAny();

  // CRUD operations for app settings (delegates to SettingsDao)

  Future<void> upsertSettings({
    required String id,
    required int lastUpdatedAt,
    required String jsonData,
  }) =>
      settingsDao.upsert(
        id: id,
        lastUpdatedAt: lastUpdatedAt,
        jsonData: jsonData,
      );

  Future<AppSetting?> getSettings(String id) => settingsDao.getById(id);

  Future<bool> hasSettings(String id) => settingsDao.exists(id);

  // Database management operations (delegates to DAOs)

  Future<void> deleteAllTransactions() => transactionDao.deleteAll();

  Future<void> deleteAllAccounts() => accountDao.deleteAll();

  Future<void> deleteAllCategories() => categoryDao.deleteAll();

  Future<void> deleteAllSettings() => settingsDao.deleteAll();

  Future<void> deleteAllData({bool includeSettings = false}) async {
    await transaction(() async {
      await deleteAllTransactions();
      await deleteAllAccounts();
      await deleteAllCategories();
      if (includeSettings) {
        await deleteAllSettings();
      }
    });
  }
}
