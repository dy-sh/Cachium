
## Stage 1
---

### 1. Общая концепция Stage 1
**Цель:** Создать локальную базу данных (SQLite), которая **автоматически** шифрует конфиденциальные данные перед записью на диск и расшифровывает их при чтении.

**Главный принцип:** Код приложения (UI) работает с обычными объектами (Dart classes), а база данных хранит "черный ящик" (зашифрованные байты). Преобразование происходит прозрачно.

---

### 2. Ключевые компоненты

#### А. Модель данных (`TransactionData`)
Это чистый Dart-класс (используем `Freezed`), который содержит всё, что мы хотим скрыть:
*   Сумма (`amount`)
*   Описание (`description`)
*   Категория (`category`)
*   Валюта (`currency`)

**Важный нюанс:** В промпте сказано: *"Include ID and Date inside the JSON model to verify integrity"*.
Это значит, что внутри этого секретного JSON мы дублируем `id` и `date`.
*   **Зачем?** Это защита от подмены (Anti-Tampering). Если злоумышленник (или "баг" сервера) возьмет зашифрованный блоб от транзакции "Покупка кофе за $5" и подсунет его в строку с ID транзакции "Зарплата $5000", при расшифровке мы увидим:
    *   ID строки в БД: `uuid-1` (Зарплата)
    *   ID внутри JSON: `uuid-2` (Кофе)
    *   **РЕЗУЛЬТАТ:** Мы выбрасываем ошибку безопасности (`SecurityException`).

#### Б. Таблица базы данных (`Transactions`)
В базе данных Drift (SQLite) структура будет гибридной. Мы не шифруем всё подряд, иначе база станет бесполезной для сортировки и синхронизации.

| Колонка | Тип | Содержание | Зашифровано? | Зачем нужно? |
| :--- | :--- | :--- | :--- | :--- |
| `id` | UUID | Уникальный ID | **НЕТ** | Первичный ключ, нужен для связей. |
| `date` | Int | Unix Timestamp | **НЕТ** | Чтобы быстро сортировать список по дате (`ORDER BY date`) без расшифровки всех строк. |
| `last_updated_at` | Int | Timestamp | **НЕТ** | Для логики синхронизации (Last Write Wins). |
| `is_deleted` | Bool | Флаг удаления | **НЕТ** | "Мягкое удаление". Мы не стираем строку, а помечаем её удаленной для синхронизации. |
| `encrypted_blob` | Blob | Uint8List | **ДА** | Здесь лежит JSON `TransactionData`, зашифрованный алгоритмом AES-GCM (или ChaCha20). Для SQLite это просто набор случайных байт. |

#### В. Магия Drift: `TypeConverter`
Drift имеет механизм `TypeConverter`. Это "мост" между Dart и SQL.

1.  **При записи (INSERT/UPDATE):**
    *   Приложение дает объект `TransactionData`.
    *   Конвертер превращает его в JSON-строку.
    *   Конвертер берет **Ключ Шифрования** (пока что заглушку, позже — настоящий ключ).
    *   Шифрует JSON в байты (Ciphertext).
    *   Drift записывает эти байты в колонку `encrypted_blob`.

2.  **При чтении (SELECT):**
    *   Drift читает байты из `encrypted_blob`.
    *   Конвертер расшифровывает их ключом.
    *   Превращает JSON обратно в объект `TransactionData`.
    *   **Проверка целостности:** Сравнивает `id` из JSON с `id` из колонки.
    *   Приложение получает готовый объект.

**Почему это круто?** В коде репозитория вы просто пишете `database.select(transactions).get()`. Вы не думаете о шифровании каждый раз. Оно происходит само.

---

### 3. Ограничения этого подхода (Важно понимать)
Так как данные зашифрованы, SQL-движок (SQLite) их не "видит".

*   **Что НЕЛЬЗЯ делать:** `SELECT * FROM transactions WHERE amount > 1000`.
    *   SQLite не может сравнить зашифрованные байты с числом 1000.
*   **Как это решается:** Фильтрация происходит **в памяти** (In-Memory).
    1.  Загружаем транзакции (например, за текущий месяц, используя открытую колонку `date`).
    2.  Они автоматически расшифровываются.
    3.  В Dart-коде делаем `.where((t) => t.amount > 1000)`.
    *   *Для личных финансов (даже 50,000 транзакций) современные телефоны справляются с этим мгновенно.*

---

### 4. Desktop-специфика (Windows/Linux)
В задании упомянута библиотека `sqlite3_flutter_libs`.
*   На Android/iOS SQLite встроен в систему.
*   На Windows/Linux его часто нет "из коробки" или версия старая.
*   Эта библиотека кладет нужный файл `sqlite3.dll` (Windows) или `libsqlite3.so` (Linux) прямо в папку с вашей программой. Это гарантирует, что приложение не упадет с ошибкой "Dll missing" при запуске на компьютере.

---

### Итог Stage 1
В конце этого этапа у нас будет приложение, которое выглядит как обычный список дел/транзакций. Но если мы откроем файл базы данных (`.sqlite`) через "DB Browser for SQLite", мы увидим даты и ID, но вместо денег и описаний — **нечитаемую кашу из байтов**.



---------------------

## Stage 2

---

### Главная концепция: Иерархия Ключей

В обычных приложениях пароль пользователя отправляется на сервер для проверки. В нашем случае **пароль — это криптографический инструмент**, который никогда не должен покидать устройство в открытом виде (для целей шифрования).

Мы строим систему из двух уровней ключей:

1.  **Master Key (MK):**
    *   Это 32 байта абсолютно случайных данных (Random Bytes).
    *   Именно этим ключом шифруется вся локальная база данных (SQLite).
    *   **Важно:** Этот ключ никогда не меняется (пока мы не сделаем ротацию ключей в будущем), даже если пользователь сменит пароль.

2.  **Key Encryption Key (KEK) — Ключ для шифрования ключа:**
    *   Этот ключ *выводится* (derive) из пароля пользователя с помощью алгоритма **Argon2id**.
    *   Он нужен **только** для того, чтобы зашифровать Master Key перед отправкой его в облако.

---

### Детальный разбор задач (Tasks)

#### 1. CryptoService и Изоляты (Isolates)

**Задача:** Реализовать функцию `deriveKeyFromPassword(password, salt)`.

*   **Почему Argon2id?** Это алгоритм хеширования, устойчивый к перебору на видеокартах (ASIC/GPU resistance). Он требует много оперативной памяти и времени. Это защита от хакеров, которые украдут базу и попытаются подобрать пароли.
*   **Зачем `compute()` (Isolate)?** Хороший хеш Argon2id должен вычисляться около 0.5–1.0 секунды на современном телефоне. Если запустить это в главном потоке Flutter (Main Thread), интерфейс приложения "замерзнет" на секунду. Пользователь подумает, что приложение зависло. Поэтому мы выносим эту тяжелую математику в отдельный изолят.

#### 2. Auth Flow: Регистрация (Создание Хранилища)

Когда пользователь регистрируется, происходит следующее:

1.  **Генерация MK:** Приложение создает случайные 32 байта. Это наш "Святой Грааль".
2.  **Генерация KEK:** Пользователь вводит пароль. Приложение в изоляте превращает `Пароль + Случайная Соль` в `KEK`.
3.  **Создание `vault.json`:** Приложение берет MK и шифрует его с помощью KEK. Получается зашифрованный "blob".
4.  **Загрузка в Supabase:**
    *   Мы регистрируем пользователя в Supabase Auth (чтобы получить `user_id`).
    *   Мы загружаем этот зашифрованный blob (файл `vault.json`) в Supabase Storage.
    *   **Итог:** Сервер Supabase видит файл, но внутри него — мусор. Сервер не знает ни пароля, ни Master Key.

#### 3. Auth Flow: Логин (Новое устройство)

Пользователь купил новый телефон и хочет войти:

1.  **Supabase Auth:** Вводит email/пароль для входа в учетку Supabase. Это дает право *скачать* файл.
2.  **Скачивание:** Приложение скачивает `vault.json`.
3.  **Расшифровка:**
    *   Приложение просит ввести "Пароль шифрования" (обычно тот же, что и от аккаунта, но технически может быть другим).
    *   Снова запускается Argon2id -> получаем KEK.
    *   Пытаемся расшифровать `vault.json` с помощью KEK.
    *   **Успех:** Мы достали Master Key! Теперь можно расшифровать локальную базу данных.
    *   **Ошибка:** Если пароль неверный, расшифровка (AES-GCM) выдаст ошибку целостности (MAC check failed).

#### 4. Quick App Launch (Быстрый вход)

Вводить сложный пароль при каждом запуске приложения неудобно.

*   **Решение:** После успешного входа мы сохраняем **Master Key** в защищенное хранилище ОС.
    *   **iOS:** Keychain.
    *   **Android:** EncryptedSharedPreferences (Keystore).
    *   **Linux:** Libsecret (Gnome Keyring / KWallet). *Именно поэтому в требованиях указан `libsecret-1-dev`.*
    *   **Windows:** DPAPI (через библиотеку `flutter_secure_storage`).
*   **Логика:** При старте приложение проверяет SecureStorage. Если там есть MK — пускаем пользователя мгновенно (или просим биометрию). Если нет — просим пароль и идем за `vault.json`.

#### 5. "No Reset" Policy (Точка невозврата)

Это архитектурное следствие Zero-Knowledge.

*   **Проблема:** Если пользователь забыл пароль, он не может сгенерировать правильный KEK.
*   **Следствие:** Он не может расшифровать `vault.json`. Он не может достать Master Key. Данные в базе — это просто набор случайных байтов, которые невозможно восстановить.
*   **UI:** Мы обязаны показать страшное красное окно: *"Мы не храним ваш пароль. Если вы его забудете, ваши деньги и данные будут потеряны навсегда. Восстановить невозможно."*

---

### Почему это безопасно?

1.  **Сервер скомпрометирован:** Хакер скачивает `vault.json`. Без пароля пользователя (который не хранится на сервере) это бесполезно.
2.  **Перехват трафика:** Весь трафик HTTPS, но даже если SSL взломан, внутри лежат только зашифрованные блобы.
3.  **Подмена данных:** Мы используем аутентифицированное шифрование (AES-GCM). Если сервер попробует подменить байты в `vault.json`, при расшифровке на клиенте вылетит исключение, и приложение не примет поддельный ключ.

### Итог Stage 2

К концу этого этапа будет приложение, которое:
1.  Умеет "дробить" пароль тяжелой математикой, не тормозя UI.
2.  Хранит ключи так, что даже разработчик сервера не может прочитать данные.
3.  Работает удобно (биометрия/авто-вход) благодаря Secure Storage.
4.  Готово к синхронизации (так как ключи теперь есть и они одинаковы на всех устройствах одного юзера).

---------------------

## Stage 3

---

---------------------

## Stage 4

---

---------------------

## Stage 5

---

---------------------

## Stage 6

---